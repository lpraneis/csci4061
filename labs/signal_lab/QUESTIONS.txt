                           __________________

                            LAB 06 QUESTIONS
                           __________________


- Name: (Logan Praneis)
- NetID: (prane001)

Answer the questions below according to the lab specification. Write
your answers directly in this text file and submit it to complete Lab01.


PROBLEM 1 `birth_death.c'
=========================

A
~

  Compile `circle_of_life.c' to the program `circle_of_life' and run
  it. Examine the results and feel free to terminate execution
  early. Examine the source code if desired though it is merely a
  print/sleep loop.

  Compile `birth_death.c' to the program `birth_death'. This program is
  invoked with two arguments, another program name and a "lifetime"
  which is an integer number of seconds. Run it like
  ,----
  | $> ./birth_death ./circle_of_life 4
  `----
  and show the output below.

$> ./birth_death ./circle_of_life 4
Nants ingonyama bagithi baba
Sithi uhm ingonyama
Nants ingonyama bagithi baba
Sithi uhm ingonyama
kill result: 0
child process 10224 terminated with signal 2


B
~

  Examine the source code for `birth_death.c' and determine the system
  call the parent program (`birth_death') uses to send signals to the
  child program. Paste this line below and explain which signal is being
  sent.

    int result = kill(pid,SIGINT);           // send a interrupt signal to child

    This line sends the SIGINT (signal 2) to the child process marked by the pid
    variable. SIGINT is the singal interrupt.

C
~

  `birth_death.c' waits for a child to finish then outputs what signal
  caused it to be terminated if that was the cause of death. Paste the
  lines of code which determine if a child was terminated due to a
  signal below and mention the macros used for this purpose.

  if(WIFSIGNALED(status)){                   // check if a signal ended the child
    printf("child process %d terminated with signal %d\n",
           pid,WTERMSIG(status));
  }

  These lines of code use the WIFISIGNALED macro to check when the child
  process changes the status variable to mark that it ended. It then uses 
  the WTERMSIG macro to get the kill signal from the child process.

D
~

  Compile the program `no_interruptions.c' and run it with
  `birth_death'. Show your results below.

  Note that you may need to send signals to `no_interruptions' to
  forcibly end it. The `pkill' command is useful for this as in
  ,----
  | pkill no_inter        # send TERM signal to proc name matching "no_inter"
  | pkill -KILL no_inter  # send KILL signal to proc name matching "no_inter"
  `----

[I] âžœ ./birth_death ./no_interruptions 5
Ma-na na-na!
Ma-na na-na!
Ma-na na-na!
Ma-na na-na!

No SIGINT-erruptions allowed.
Ma-na na-na!
kill result: 0
Ma-na na-na!
Ma-na na-na!
Ma-na na-na!
Ma-na na-na!
kill result: 0

E
~

  Examine the `no_interruptions.c' code and describe how it is able to
  avoid being killed when receiving the interrupt and TERM signals. Show
  the lines of code used to accomplish this signal handling.

It uses handle_SIG... (int signum) functions to expect a SIG and then
uses the signal() system call  to handle these without killing the program.


PROBLEM 2 `start_stop.c'
========================

A
~

  Compile `start_stop.c' to the program `start_stop'. This program is
  invoked identically to `birth_death' with two arguments, another
  program name and an "interval" which is an integer number of
  seconds. Run it like
  ,----
  | $> ./start_stop ./circle_of_life 3
  `----
  and show the output below. You may terminate the program early once
  you see the pattern.

Nants ingonyama bagithi baba
Sithi uhm ingonyama
Nants ingonyama bagithi baba
SIGSTOP result: 0
SIGCONT result: 0
Sithi uhm ingonyama
Ingonyama
Siyo Nqoba
SIGSTOP result: 0


B
~

  Describe at a high level the effect that `start_stop' has on a child
  process it runs

The start_stop program kills a program with the SIGSTOP singal, prints to the screen,
waits for the sleep() count, and then restarts it with the SIGCONT flag

C
~

  Examine the source code of `start_stop.c' and determine the types of
  signals it uses to alter behavior of its child process and paste the
  corresponding lines of code below.

    result = kill(pid,SIGSTOP);              // send a stop signal to child
    result = kill(pid,SIGCONT);              // send a continue signal to child

    The SIGSTOP temporarily stops the process and then the SIGCONT restarts it.

D
~

  The program `no_interruptions.c' establishes signal handlers for some
  signals allowing it to ignore signals that would normally terminate a
  process. Investigate whether it is possible to similarly ignore the
  signal used by `start_stop' to pause its child process. Hint: Consider
  the provided program `cant_catch_sigstop.c' and run it with
  `start_stop'.

According to the manpage for signal(), 
"The signals SIGKILL and SIGSTOP cannot be caught or ignored."

That is why the handle_SIGSTOP() function is never run and never
prints the "There's no SIGSTOPping me!"  line to the screen.




